class Book:
    """ Базовый класс книги.
    Инициализирует экземпляр книги без привязки к ее физическому носителю,
    принимает только имя автора и название."""
    def __init__(self, name: str, author: str):  # вызов конструктора базового класса, принимаем автора и название
        self._name = name  # у экземпляра класса будет защищенный (1 '_', protected) атрибут с именем автора
        self._author = author  # аналогично защищенный атрибут экземлпяра с названием книги
        # защита с помощью нижнего подчеркивания формальна, физически пользователь сможет измнить значения уже после инициализации, вне класса

    @property  # для реализации физической защиты нужно перевести атрибут в свойство, и теперь всё в кассе ссылается на свойство и снача реализуется оно
    def name(self) -> str:  # свойство одноименно названию атрибута, ничего не принемает
        return self._name  # но должно возвращать значение атрибута. заменет метод "получить значение (get_value)"

    @name.setter  # для реализации записи нового значения в атрибут используется свойство setter, аналогично "set_value"
    def name(self, value) -> None:  # декоратор и название метода также одноименны атрибуту, принимает значение и ничего не возращает
        raise AttributeError('Denied')  # чтобы в явном виде объявить невозможность перезаписи значения пользователем вне класса, при попытке такой записи будет появляться ошибкаи запись не будет произведена

    @property  # аналогично объявляем защиту для атрибута автора
    def author(self) -> str:
        return self._author

    @author.setter  # аналогично блокируем в явном виде. Также, мы не можем объявить setter без getter
    def author(self, value) -> None:
        raise AttributeError('Denied')  # запрещаем доступ к перезаписи значения

    def __str__(self):  # метод возвращает строку с данными о книге. Строка выводится в представлении удобном для человеческого восприятия
        return f"Книга {self.name}. Автор {self.author}"  # выводятся значения автора и имени
    # в дочерних классах этот метод не прописан и будет наследоваться из базового класса. То есть получим представление только с этими атрибутами
    # при реализации метода в дочерних классах прочитаются их собственные значения атрибутов, и дальше интепретатор не будет их искать в базовом классе

    def __repr__(self):  # метод возвращает строку с данными о книге. Строка выводится в валидном представлении, по которому может быть иницализирован аналогичный экземпляр класса
        return f"{self.__class__.__name__}(name={self.name!r}, author={self.author!r})"
    # ссылаемся на имя класса с помощью методов класса, чтобы при дальнейшем использовании код был более универсальным.
    # К тому же, при переименовании класса не придется переписывать этот метод


class PaperBook(Book):
    """ Дочерний класс книги. Это одиночное наследование.
        Инициализирует экземпляр бумажной книги,
        принимает имя автора, название и целое количество страниц."""
    def __init__(self, name: str, author: str, pages: int):  # вызов конструктора, принимаем автора, название и кол-во страниц
        super().__init__(name, author)  # так как мы вызвали конструктор, чтобы не потерять все атрибуты, объявленные в базовом классе, вызываем этот метод
        # передаем в метод значения имени и автора, чтобы присвоить значения соответсвующим атрибутам
        self._pages = pages  # объявляем еще один атрибут. Он тоже защищенный (дальше пропишем фактическую защиту в явном виде)
        # таким образом получили 3 атрибута объекта, 2 наследованных и один, принадлежащий экземплярам только этого класса

    def __repr__(self):  # перегрузка repr. Необходима потому, что для инициализации объекта этого класса нужен еще один атрибут, а репр из базового класса не учитывает это и не видет этот атрибут
        return f"{self.__class__.__name__}(name={self.name!r}, author={self.author!r}, pages={self.pages!r})"
    # теперь возвращаемая строка будет валидной. Также лучше перегрузить репр чтобы правильно считалось имя класса,
    # потому что может прочитаться имя базового класса, и тогда строка не будет валидной

    @property  # нам нужна возможность перезаписи значения и защита от замены неправильным значением, поэтому нужны свойства
    def pages(self) -> int:  # свойство одноименно названию атрибута, ничего не принемает
        return self._pages  # но должно возвращать значение атрибута. заменет метод "получить значение (get_value)"
    # без геттера не заработает сеттер, а он и есть основная цель

    @pages.setter  # реализует возможность записи значения в атрибут а также выполняет проверки
    def pages(self, value) -> None:  # декоратор и название метода также одноименны атрибуту, принимает значение и ничего не возращает
        if not isinstance(value, int):  # проверка на соотвествие аннотации типов, так как сама аннотация лишь рекомендация
            raise TypeError('Значение должно быть целочисленным, вы не напечатате кусок листа')
        if value <= 0:  # проверка математической справедливости количества физических объектов
            raise ValueError('Значение количества страниц не может быть нулевым или отрицательным')
        self._pages = value  # если проверки успешно пройдены, присваиваем новое значение



class AudioBook(Book):
    """ Второй дочерний класс книги.  Это одиночное наследование.
    Инициализирует экземпляр аудиокниги,
    принимает имя автора, название и продолжителность прослушивания в минутах с точностью до десятых."""
    def __init__(self, name: str, author: str, duration: float):  # вызов конструктора, принимаем автора, название и продолжительность прослущивания
        super().__init__(name, author)  # так как мы вызвали конструктор, чтобы не потерять все атрибуты, объявленные в базовом классе, вызываем этот метод
        # передаем в метод значения имени и автора, чтобы присвоить значения соответсвующим атрибутам
        self._duration = duration  # объявляем еще один атрибут. Он тоже защищенный (дальше пропишем фактическую защиту в явном виде)
        # таким образом получили 3 атрибута объекта, 2 наследованных и один, принадлежащий экземплярам только этого класса

    def __repr__(self):  # перегрузка repr. Необходима потому, что для инициализации объекта этого класса нужен еще один атрибут, а репр из базового класса не учитывает это и не видет этот атрибут
        return f"{self.__class__.__name__}(name={self.name!r}, author={self.author!r}, pages={self.duration!r})"
    # теперь возвращаемая строка будет валидной. Также лучше перегрузить репр чтобы правильно считалось имя класса,
    # потому что может прочитаться имя базового класса, и тогда строка не будет валидной

    @property  # нам нужна возможность перезаписи значения и защита от замены неправильным значением, поэтому нужны свойства
    def duration(self) -> float:  # свойство одноименно названию атрибута, ничего не принемает
        return self._duration  # но должно возвращать значение атрибута. заменет метод "получить значение (get_value)"
    # без геттера не заработает сеттер, а он и есть основная цель

    @duration.setter  # реализует возможность записи значения в атрибут а также выполняет проверки
    def duration(self, value) -> None:  # декоратор и название метода также одноименны атрибуту, принимает значение и ничего не возращает
        if not isinstance(value, float):  # проверка на соотвествие аннотации типов, так как сама аннотация лишь рекомендация
            raise TypeError('Значение должно быть десятичной дробью, не строкой или текстом или чем нибудь еще')
        if value <= 0:  # проверка математической справедливости количества физических объектов
            raise ValueError('Значение продолжительности вопспроизведения не может быть нулевым или отрицательным')


parent_book = Book('Два капитана', 'Каверин')  # инициализация объекта базового класса
paper_book = PaperBook('Капитанская дочка', 'Пушкин', 250)  # инициализация объекта дочернего класса
audio_book = AudioBook('Война и мир', 'Толстой', 382.56)  # инициализация объекта дочнего класса

print(parent_book, "\n",  # печатаем - проверяем стр и репр работу для всех экземпляров
      repr(parent_book), "\n",
      paper_book, "\n",
      repr(paper_book),"\n",
      audio_book, "\n",
      repr(audio_book), "\n")


# parent_book.name = 'На дне'  Если разблокировать эти значения и попробовать перезаписать автора и имя, будет ошибка
# parent_book.author = 'Горький'


print(parent_book, "\n",  # печатаем - проверяем стр и репр работу для всех экземпляров
      repr(parent_book), "\n",
      paper_book, "\n",
      repr(paper_book),"\n",
      audio_book, "\n",
      repr(audio_book))
#пустая строка
